import ./token
import nimly

# Terminal symbols (generated by the lexer) are upper-case. 
# Non-terminal symbols (built by the parser out of other symbols) are lower-case.

nimy myParser[Token]:
  top[statement]:
    ## a pattern.
    expr:
      ## proc body that is used when parse the pattern with single ``expr``.
      ## $1 means first position of the pattern (expr)
      expression:
        return $1
      expressionEndingWithBlock:
        return $1

    declaration:
      return $1

  statement[declaration]:
    constItem
    macroInvocation
    emptyStatement
    attributeItem
    innerAttrbuteItem
    modItem
    foreignItem
    structItem
    unionItem
    enumItem
    typeItem
    functionItem
    functionSignatureItem
    implItem
    associatedType
    letDeclaration:
      TokenLet TokenMut[] TokenIdentifier OpAssign expr:

    useDeclartion:
      TokenUse 
    externCrateDeclaration
    staticItem
  # macroDefinition:
  #   macroRules
  tokenPattern:
    tokenTreePattern:
    tokenRepetitionPattern:
    nonSpecialToken:

  tokenTreePattern:
    LPAR tokenPattern RPAR:
      return $2
    SquareBracketL tokenPattern SquareBracketR:
      return $2
    BracketL tokenPattern BracketR:
      return $2
  tokenBindingPattern:
    name ":" typ
  tokenRepetitionPattern:
    "$" LPAREN tokenPattern[] RPAREN:
      # "type": "CHOICE",
      #     "members": [
      #       {
      #         "type": "PATTERN",
      #         "value": "[^+*?]+"
      #       },
      #       {
      #         "type": "BLANK"
      #       }
      #     ]
      # {
      #     "type": "CHOICE",
      #     "members": [
      #       {
      #         "type": "STRING",
      #         "value": "+"
      #       },
      #       {
      #         "type": "STRING",
      #         "value": "*"
      #       },
      #       {
      #         "type": "STRING",
      #         "value": "?"
      #       }
      #     ]
  # {
  #         "type": "PATTERN",
  #         "value": "[/_\\-=->,;:::!=?.@*=/=&=#%=^=+<>|~]+"
  #       },
  fragmentSpecifier:
    # block
    expr
    ident
    item
    lifetime
    literal
    meta
    pat
    path
    stmt
    tt
    ty
    vis

  attributeItem:
    "#" "[" metaItem "]"
  innerAttributeItem:
    "#" "!" "[" metaItem "]"
  metaItem:
    # https://github.com/tree-sitter/tree-sitter-rust/blob/40620bf4097cbc9cea79504d7e877865df43a19e/src/grammar.json#L928
  
  expr[Expr]:
    ## first pattern of expr.
    ## ``LPAR`` and ``RPAR`` is TokenKind.
    LPAR expr RPAR:
      return $2

    ## second pattern of expr.
    ## ``PLUS`` is TokenKind.
    expr PLUS expr:
      return $2

  plus[string]:
    mult PLUS plus:
      return $1 & " + " & $3

    mult:
      return $1

  mult[string]:
    num MULTI mult:
      return "[" & $1 & " * " & $3 & "]"

    num:
      return $1

  num[string]:
    LPAREN plus RPAREN:
      return "(" & $2 & ")"

    ## float (integer part is 0-9) or integer
    NUM DOT[] NUM{}:
      result = ""

      # type of `($1).val` is `int`
      result &= $(($1).val)

      if ($2).len > 0:
        result &= "."

      # type of `$3` is `seq[MyToken]` and each elements are NUM
      for tkn in $3:
        # type of `tkn.val` is `int`
        result &= $(tkn.val)
